1ï¸âƒ£ Indexing
What is Indexing?

Indexing is used to speed up data retrieval from a table.

Without an index:

Database scans every row (full table scan)

Very slow for large tables

With an index:

Database can jump directly to required rows

Faster query execution

2ï¸âƒ£ Clustered Index
What is a Clustered Index?

A clustered index determines the physical order of data rows in a table.

 Data is stored on disk in the same order as the clustered index.

Key Points

Only ONE clustered index per table

Usually created on the Primary Key

Because data itself is sorted, searching is faster

Clustered Index â†’ Primary Key

3ï¸âƒ£ Non-Clustered Index
What is a Non-Clustered Index?

A non-clustered index is created on non-primary key columns.

Data order does not change

Index stores:

Column value

Pointer to actual row

Why use it?

Speeds up filtering on non-PK columns

Improves execution time

CREATE INDEX idx_email
ON customer(email);

4ï¸âƒ£ Why Indexing Matters

Without index:

SELECT * FROM rental WHERE rental_date = '2005-05-10';


â†’ Scans entire table âŒ

With index:
â†’ Direct lookup âœ…

5ï¸âƒ£ Natural Key vs Surrogate Key
Natural Key

A natural key:

Already exists in real world

Naturally unique

Examples:

Email

SSN

Passport number

email â†’ natural key

Surrogate Key

A surrogate key:

Generated by the system

Has no business meaning

Used only for identification

Examples:

customer_id

employee_id

customer_id (AUTO_INCREMENT) â†’ surrogate key

Difference Table (EXAM IMPORTANT)
Natural Key	Surrogate Key
Real-world data	System-generated
Can change	Never changes
Meaningful	No meaning
Slower joins	Faster joins
6ï¸âƒ£ Safe Updates
What is Safe Update Mode?

Safe updates prevent accidental updates or deletes without a condition.

Example of dangerous query:

DELETE FROM customer;


Safe mode prevents this.

Enable Safe Updates
SET SQL_SAFE_UPDATES = 1;

Disable Safe Updates
SET SQL_SAFE_UPDATES = 0;


Safe updates require:

WHERE clause
OR

LIMIT

7ï¸âƒ£ SQL Query Fine Tuning (VERY IMPORTANT)
âœ… Use Only Necessary Columns

âŒ Bad:

SELECT * FROM customer;


âœ… Good:

SELECT customer_id, first_name FROM customer;

âœ… Use WHERE Before GROUP BY / HAVING

WHERE filters rows

HAVING filters groups

SELECT customer_id, COUNT(*)
FROM rental
WHERE rental_date >= '2005-01-01'
GROUP BY customer_id;

âœ… Use JOINs Instead of Subqueries

JOINs are usually faster and clearer.

âŒ Subquery:

SELECT * FROM customer
WHERE customer_id IN (SELECT customer_id FROM rental);


âœ… JOIN:

SELECT DISTINCT c.*
FROM customer c
JOIN rental r ON c.customer_id = r.customer_id;

âŒ Avoid Functions on Indexed Columns

âŒ Bad (index NOT used):

SELECT * FROM rental
WHERE YEAR(rental_date) = 2005;


âœ… Good (index used):

SELECT * FROM rental
WHERE rental_date BETWEEN '2005-01-01' AND '2005-12-31';

âœ… Use LIMIT Effectively
SELECT * FROM payment
LIMIT 10;

âŒ Avoid Large OFFSET in Pagination

âŒ Inefficient:

SELECT * FROM sakila.payment
LIMIT 1000, 10;


âœ… Efficient:

SELECT * FROM sakila.payment
WHERE payment_id > 1000
LIMIT 10;

8ï¸âƒ£ Use CTE for Readable Queries

CTEs improve readability, not performance.

WITH high_payments AS (
    SELECT * FROM payment WHERE amount > 5
)
SELECT * FROM high_payments;

9ï¸âƒ£ Use EXPLAIN
What is EXPLAIN?

EXPLAIN shows how MySQL executes a query.

EXPLAIN SELECT * FROM rental WHERE rental_date = '2005-05-10';


Helps identify:

Index usage

Full table scan

Join methods

ðŸ”Ÿ Maintenance Commands
ANALYZE

Updates table statistics.

ANALYZE TABLE payment;

OPTIMIZE

Reorganizes table and index storage.

OPTIMIZE TABLE payment;


ðŸ“Œ Run periodically for performance.

ðŸ§  One-Line Exam Memory Notes

Clustered index â†’ physical data order

One clustered index per table

PK â†’ clustered index

Non-clustered index â†’ faster filtering

Natural key â†’ real-world unique

Surrogate key â†’ system-generated

Safe updates â†’ prevents accidental changes

Avoid functions on indexed columns

JOIN > subquery

Use EXPLAIN for tuning

Use LIMIT smartly
