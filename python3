uples->immutable
()
same as list 

x=(1,2,3)
l=list(x)->makes tuple into list 
sets->unordered collection of unique elements 
{}->has unique values if there is 4 in this set and trying to add again then it wont add
unordered dosent have index for specific value
Strings
Escape Character

\n â†’ new line

ðŸ”¹ String Slicing
s = "hello world"

s[0:]      # hello world
s[:5]      # hello
s[0:5:2]   # hlo


s[start:end:step]

ðŸ”¹ String Properties

Immutable (cannot change characters)

Concatenation â†’ +

ðŸ”¹ String Methods
s.upper()
s.lower()
s.split()
s.partition("e")
s.count("o")
s.find("o")
s.isalnum()
s.isalpha()
s.isspace()
s.istitle()

ðŸ”¹ Lists

Mutable

Can store multiple data types

l = [1, "a", 3.5]

Methods
l.append()
l.pop()
l.reverse()

ðŸ”¹ Nested List (Matrix)
l1 = [1,2,3]
l2 = [4,5,6]
l3 = [7,8,9]


ðŸ”¹ Tuples

Immutable

Uses ()

x = (1,2,3)


Convert tuple to list:

l = list(x)

ðŸ”¹ Sets

Unordered

Unique values only

No indexing

s = {1,2,3,4}


If you add duplicate â†’ ignored.

ðŸ”¹ Dictionary
my_dict = {
    True: "val1",
    "key2": "val2",
    "key3": [1,"b",3],
    "key4": 123
}


Access:

my_dict["key2"]
my_dict["key3"][1].upper()

ðŸ”¹ Dictionary Comprehension
d = {x: x**2 for x in range(1,11)}

dict
my_dict={true:'val1','key2':'val2','key3':[1,b,3],'key4':123}

my_dict['key2'] will give val2

my_dict['key2'][0]-->1

my_dict['key2'][1].upper-->B
new dict is like d={}

nested dict

dict comprehensions
d{}
for x in range(1,11):
	d{x}=x**2


ðŸ”¹ Shallow Copy vs Deep Copy
import copy

original = [[1,2],[3,4]]

shallow = copy.copy(original)
deepcopy = copy.deepcopy(original)


Shallow â†’ changes affect original

Deep â†’ fully independent copy

ðŸ”¹ Functions
def print_num(n):
    for i in range(1, 6):
        print(i * n)

print_num(8)

ðŸ”¹ print vs return
print:

Cannot store result

def add(a,b):
    print(a+b)

return:

Can assign to variable

def add(a,b):
    return a+b

x = add(5,6)
